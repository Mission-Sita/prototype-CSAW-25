#!/usr/bin/env python3
import asyncio
import json
import os
import subprocess
import tempfile
from pathlib import Path
from typing import Optional

from mcp.server import Server
from mcp.server.stdio import stdio_server

server = Server("Run Commands MCP")


def _clean_text(text: Optional[bytes]) -> Optional[str]:
    if text is None:
        return None
    return text.decode("utf-8", errors="backslashreplace").replace("\r\n", "\n")


async def _docker_exec(container_id: str, command: str, timeout: float) -> dict:
    proc = subprocess.Popen(
        ["docker", "exec", container_id, "bash", "-c", command],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )
    try:
        stdout, stderr = proc.communicate(timeout=timeout)
        return {
            "stdout": _clean_text(stdout),
            "stderr": _clean_text(stderr),
            "returncode": proc.returncode,
            "timed_out": False,
        }
    except subprocess.TimeoutExpired:
        try:
            proc.kill()
        except Exception:
            pass
        stdout, stderr = proc.communicate()
        return {
            "stdout": _clean_text(stdout),
            "stderr": _clean_text(stderr),
            "returncode": None,
            "timed_out": True,
        }


@server.tool()
async def run_in_container(
    container_id: str,
    command: str,
    timeout: float = 10.0,
) -> str:
    """
    Run a shell command inside a Docker container via `docker exec`.

    Args:
        container_id: The Docker container ID or name to exec into
        command: Shell command to run
        timeout: Max seconds to allow the command to run

    Returns:
        JSON string with fields: stdout, stderr, returncode, timed_out
    """
    if not container_id:
        return json.dumps({"error": "container_id is required"})
    if command is None:
        return json.dumps({"error": "command is required"})

    result = await _docker_exec(container_id, command, timeout)
    return json.dumps(result)


def _expand_user_path(path_str: str, home: Path) -> Path:
    if path_str.startswith("~"):
        path_str = path_str.replace("~", str(home), 1)
    return Path(path_str)


async def _copy_bytes_into_container(container_id: str, data: bytes, dest_path: Path) -> dict:
    # Ensure parent directory exists inside the container
    try:
        subprocess.run(
            [
                "docker",
                "exec",
                container_id,
                "mkdir",
                "-p",
                str(dest_path.parent),
            ],
            check=False,
            capture_output=True,
        )
    except Exception as e:
        return {"error": f"mkdir in container failed: {e}"}

    with tempfile.NamedTemporaryFile(mode="wb", delete=False) as tmp:
        tmp.write(data)
        tmp.flush()
        tmp_path = tmp.name

    try:
        cp = subprocess.run(
            ["docker", "cp", "-aq", tmp_path, f"{container_id}:{dest_path}"],
            capture_output=True,
            text=True,
        )
        if cp.returncode != 0:
            return {
                "error": "docker cp failed",
                "stderr": cp.stderr,
                "stdout": cp.stdout,
                "returncode": cp.returncode,
            }
        return {"success": True, "path": str(dest_path)}
    finally:
        try:
            os.remove(tmp_path)
        except Exception:
            pass


@server.tool()
async def create_file_in_container(
    container_id: str,
    path: str,
    contents: str,
    decode_escapes: bool = False,
    container_home: str = "/home/ctfplayer",
) -> str:
    """
    Create a file inside the given Docker container with provided contents.

    Args:
        container_id: Docker container ID or name
        path: Destination file path inside container (absolute or relative to container_home)
        contents: File contents (string). If decode_escapes is true, backslash escapes will be interpreted.
        decode_escapes: Whether to decode escape sequences before writing
        container_home: Home directory inside container used for relative paths

    Returns:
        JSON string with success/error details
    """
    if not container_id:
        return json.dumps({"error": "container_id is required"})
    if not path:
        return json.dumps({"error": "path is required"})
    if contents is None:
        return json.dumps({"error": "contents is required"})

    try:
        data = (
            bytes(contents, "utf-8").decode("unicode_escape").encode("latin-1")
            if decode_escapes
            else contents.encode()
        )
    except Exception as e:
        return json.dumps({"error": f"invalid contents encoding: {e}"})

    dest = Path(path)
    if not dest.is_absolute():
        dest = Path(container_home) / dest

    result = await _copy_bytes_into_container(container_id, data, dest)
    return json.dumps(result)


@server.tool()
async def list_running_containers() -> str:
    """
    List running Docker containers (id and names) to help select the target container.

    Returns:
        JSON string listing containers as [{id, names}]
    """
    ps = subprocess.run(
        ["docker", "ps", "--format", "{{.ID}}\t{{.Names}}"],
        capture_output=True,
        text=True,
    )
    if ps.returncode != 0:
        return json.dumps({"error": ps.stderr.strip(), "returncode": ps.returncode})

    items = []
    for line in ps.stdout.splitlines():
        parts = line.split("\t", 1)
        if len(parts) == 2:
            items.append({"id": parts[0], "names": parts[1]})
    return json.dumps(items)


async def main() -> None:
    async with stdio_server() as (read_stream, write_stream):
        await server.run(read_stream, write_stream)


if __name__ == "__main__":
    asyncio.run(main()) 