import subprocess
import traceback as tb
from pathlib import Path
from nyuctf.challenge import CTFChallenge
from .ctflogging import status  # keep if baseline provides it; otherwise replace with print()

class CTFEnvironment:
    """
    Simplified environment manager for challenges â€” NO automatic tool construction.
    The PentestAgent (or MCP managers) can register tools into env.available_tools
    via register_tool(name, instance).

    Responsibilities:
      - Start/stop challenge container (docker run)
      - Copy provided challenge files into the container
      - Expose a small tool registry API for the rest of the system to use
    """

    def __init__(self, challenge: CTFChallenge, container_image: str, network: str):
        self.challenge = challenge
        self.container_image = container_image
        self.network = network

        # Tools will be registered by the PentestAgent / MCP servers after they start
        # e.g., env.register_tool("validator", validator_obj)
        self.available_tools = {}

        # State flags
        self.solved = False   # can be set by a CheckFlag-like tool
        self.giveup = False   # can be set by a GiveUp-like tool

        # Container id after start_docker()
        self.container = None

    # ---------- Tool registry API ----------
    def register_tool(self, name: str, tool_instance) -> None:
        """Register a tool instance with a name for later lookup."""
        status.debug_message(f"Registering tool '{name}' into environment.")
        self.available_tools[name] = tool_instance

    def unregister_tool(self, name: str) -> None:
        """Remove a previously registered tool."""
        if name in self.available_tools:
            status.debug_message(f"Unregistering tool '{name}'.")
            del self.available_tools[name]

    def get_tool(self, name: str):
        """Return the tool instance or None if not present."""
        return self.available_tools.get(name)

    # ---------- Lifecycle ----------
    def setup(self):
        """Start the container and (optionally) initialize tools if they exist."""
        status.debug_message(f"Setting up challenge environment for {self.challenge}")
        try:
            self.start_docker()
        except Exception as e:
            status.debug_message(f"ERROR starting docker: {e}")
            raise

        # Copy challenge files into container (if any)
        for file in getattr(self.challenge, "files", []):
            hostpath = Path(self.challenge.challenge_dir) / file
            try:
                self.copy_into_container(hostpath, f"ctf_files/{file}")
            except Exception as e:
                status.debug_message(f"Warning: failed to copy {hostpath} into container: {e}")

        status.debug_message("Environment setup complete. Tools should be registered by agent (MCP).")

    def teardown(self, exc_type=None, exc_value=None, traceback=None):
        """Tear down registered tools (if they provide a teardown) then stop the container."""
        status.debug_message("Tearing down environment: cleaning up tools then stopping container...")
        # Call teardown on tools if they expose it (best-effort)
        for name, tool in list(self.available_tools.items()):
            try:
                if hasattr(tool, "teardown"):
                    status.debug_message(f"Calling teardown on tool '{name}'")
                    tool.teardown(exc_type, exc_value, traceback)
            except Exception as e:
                status.debug_message(f"Tool '{name}' teardown raised an exception: {e}")

        # Stop the container (best-effort)
        try:
            self.stop_docker()
        except Exception as e:
            status.debug_message(f"Error stopping docker container: {e}")

    # ---------- Docker helpers ----------
    def start_docker(self):
        """Start the challenge container using docker run (single-container path)."""
        status.debug_message(f"Starting environment container {self.container_image}...")
        cmd = [
            "docker", "run", "-d", "--rm",
            "--network", self.network, "--platform", "linux/amd64",
            self.container_image
        ]
        output = subprocess.run(cmd, check=True, capture_output=True, text=True)
        self.container = output.stdout.strip()
        status.debug_message(f"...started {self.container}")

    def copy_into_container(self, hostpath: Path, filename: str) -> Path:
        """
        Copy a host file into the running container at container_home/filename (or absolute path if filename absolute).
        Returns the Path used inside the container.
        """
        if Path(filename).is_absolute():
            containerpath = Path(filename)
        else:
            containerpath = self.container_home / filename
            # Make parent path inside container
            cmd = ["docker", "exec", self.container, "mkdir", "-p", str(containerpath.parent)]
            subprocess.run(cmd, capture_output=True)

        status.debug_message(f"Copying file {hostpath} into container {self.container} at {containerpath}")
        cmd = ["docker", "cp", "-aq", str(hostpath), f"{self.container}:{containerpath}"]
        subprocess.run(cmd, capture_output=True)
        return containerpath

    def stop_docker(self):
        """Stop the running container."""
        if not self.container:
            status.debug_message("No container to stop.")
            return
        status.debug_message(f"Stopping environment container {self.container_image} {self.container}...")
        subprocess.run(["docker", "stop", self.container], check=True, capture_output=True)
        self.container = None

    @property
    def container_home(self) -> Path:
        return Path("/home/ctfplayer")
